{"version":3,"sources":["../../src/middleware/index.ts","../../src/utils/getAttributes.ts","../../src/utils/metrics-manager.ts","../../src/middleware/timing-utils.ts"],"sourcesContent":["import { SpanStatusCode, trace } from \"@opentelemetry/api\";\nimport {\n\tATTR_HTTP_REQUEST_METHOD,\n\tATTR_HTTP_RESPONSE_STATUS_CODE,\n\tATTR_HTTP_ROUTE,\n\tATTR_NETWORK_LOCAL_ADDRESS,\n\tATTR_URL_FULL,\n\tATTR_URL_PATH,\n\tATTR_URL_SCHEME,\n} from \"@opentelemetry/semantic-conventions\";\nimport type { APIContext, MiddlewareNext } from \"astro\";\nimport { OTEL_SERVICE_VERSION } from \"../utils/getAttributes.js\";\nimport {\n\tcreateMetricsForExporter,\n\tgetCurrentExporter,\n} from \"../utils/metrics-manager.js\";\nimport {\n\tmeasureTTLBWithAsyncTiming,\n\tmeasureTTLBWithStreamWrapping,\n\ttype TimingOptions,\n} from \"./timing-utils.js\";\n\nconst tracer = trace.getTracer(\n\t\"astro-opentelemetry-integration-request-tracer\",\n\tOTEL_SERVICE_VERSION,\n);\n\n// Create metrics conditionally based on exporter type (OpenTelemetry best practice)\nconst currentExporter = getCurrentExporter();\nconst metricsInstruments = createMetricsForExporter(currentExporter);\n\n// Extract metrics for easier access\nconst { httpRequestsTotal, httpRequestDuration, httpServerDurationSeconds } =\n\tmetricsInstruments;\n\nexport async function onRequest(ctx: APIContext, next: MiddlewareNext) {\n\tconst { request, url } = ctx;\n\n\tconst spanName = `HTTP ${request.method} ${url.pathname}`;\n\n\t// Start timer for metrics using performance.now()\n\tconst startTime = performance.now();\n\tconst path = url.pathname || \"/\";\n\n\t// `startActiveSpan` creates a new span and sets it as the active span\n\t// for the duration of the callback. This is crucial for parent-child\n\t// relationships between spans.\n\treturn tracer.startActiveSpan(spanName, async (span) => {\n\t\t// Set standard HTTP attributes on the span.\n\t\tspan.setAttributes({\n\t\t\t[ATTR_HTTP_REQUEST_METHOD]: request.method,\n\t\t\t[ATTR_URL_SCHEME]: url.protocol.replace(\":\", \"\"),\n\t\t\t[ATTR_NETWORK_LOCAL_ADDRESS]: url.hostname,\n\t\t\t[ATTR_URL_PATH]: url.pathname,\n\t\t\t// Note: Astro doesn't provide route pattern in APIContext, using pathname instead\n\t\t\t[ATTR_HTTP_ROUTE]: url.pathname,\n\t\t\t[ATTR_URL_FULL]: url.toString(),\n\t\t});\n\n\t\ttry {\n\t\t\tconst response = await next();\n\n\t\t\t// Record the status code on the span.\n\t\t\tspan.setAttribute(ATTR_HTTP_RESPONSE_STATUS_CODE, response.status);\n\n\t\t\t// If status is 4xx or 5xx, set the span status to ERROR.\n\t\t\tif (response.status >= 400) {\n\t\t\t\tspan.setStatus({\n\t\t\t\t\tcode: SpanStatusCode.ERROR,\n\t\t\t\t\tmessage: `HTTP error ${response.status}`,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t// Calculate duration for metrics using performance.now()\n\t\t\tconst duration = (performance.now() - startTime) / 1000; // Convert to seconds\n\n\t\t\t// Record metrics with same labels as Prometheus implementation\n\t\t\tconst labels = {\n\t\t\t\tmethod: request.method,\n\t\t\t\tpath: path,\n\t\t\t\tstatus: response.status.toString(),\n\t\t\t};\n\n\t\t\t// Record request duration histogram (if enabled)\n\t\t\tif (httpRequestDuration) {\n\t\t\t\thttpRequestDuration.record(duration, labels);\n\t\t\t}\n\n\t\t\t// Record request counter (only for Prometheus)\n\t\t\tif (httpRequestsTotal) {\n\t\t\t\thttpRequestsTotal.add(1, labels);\n\t\t\t}\n\n\t\t\t// Handle streaming responses for http_server_duration_seconds (TTLB)\n\t\t\tif (\n\t\t\t\tresponse.body instanceof ReadableStream &&\n\t\t\t\thttpServerDurationSeconds\n\t\t\t) {\n\t\t\t\tconst timingOptions: TimingOptions = {\n\t\t\t\t\tstartTime,\n\t\t\t\t\tlabels,\n\t\t\t\t\thistogram: httpServerDurationSeconds,\n\t\t\t\t};\n\n\t\t\t\t// Check for experimental optimized TTLB measurement\n\t\t\t\tconst useOptimized =\n\t\t\t\t\tglobalThis.__OTEL_PRESETS__?.experimental\n\t\t\t\t\t\t?.useOptimizedTTLBMeasurement;\n\n\t\t\t\tif (useOptimized) {\n\t\t\t\t\treturn measureTTLBWithAsyncTiming(response, timingOptions);\n\t\t\t\t}\n\t\t\t\treturn measureTTLBWithStreamWrapping(response, timingOptions);\n\t\t\t}\n\n\t\t\t// For non-streaming responses, record server duration immediately (if enabled)\n\t\t\tif (httpServerDurationSeconds) {\n\t\t\t\thttpServerDurationSeconds.record(duration, labels);\n\t\t\t}\n\n\t\t\treturn response;\n\t\t} catch (error) {\n\t\t\t// Calculate duration for error metrics using performance.now()\n\t\t\tconst duration = (performance.now() - startTime) / 1000; // Convert to seconds\n\t\t\tconst errorLabels = {\n\t\t\t\tmethod: request.method,\n\t\t\t\tpath: path,\n\t\t\t\tstatus: \"500\",\n\t\t\t};\n\n\t\t\t// Record error metrics (if enabled)\n\t\t\tif (httpRequestDuration) {\n\t\t\t\thttpRequestDuration.record(duration, errorLabels);\n\t\t\t}\n\t\t\tif (httpRequestsTotal) {\n\t\t\t\thttpRequestsTotal.add(1, errorLabels);\n\t\t\t}\n\t\t\tif (httpServerDurationSeconds) {\n\t\t\t\thttpServerDurationSeconds.record(duration, errorLabels);\n\t\t\t}\n\n\t\t\t// If an unhandled error occurs, record it on the span and re-throw.\n\t\t\tif (error instanceof Error) {\n\t\t\t\tspan.recordException(error);\n\t\t\t}\n\t\t\tspan.setStatus({\n\t\t\t\tcode: SpanStatusCode.ERROR,\n\t\t\t\tmessage: (error as Error)?.message,\n\t\t\t});\n\t\t\tthrow error;\n\t\t} finally {\n\t\t\t// End the span when the request is done.\n\t\t\tspan.end();\n\t\t}\n\t});\n}\n","export const OTEL_SERVICE_NAME =\n\tglobalThis.__OTEL_OPTIONS__.serviceName || process.env.OTEL_SERVICE_NAME;\nexport const OTEL_SERVICE_VERSION =\n\tglobalThis.__OTEL_OPTIONS__.serviceVersion ||\n\tprocess.env.OTEL_SERVICE_VERSION;\n","/**\n * Conditional metrics creation based on exporter type\n * Follows OpenTelemetry best practices for different exporters\n */\n\nimport { metrics } from \"@opentelemetry/api\";\nimport type { IntegrationSchema } from \"../integrationSchema.js\";\nimport { OTEL_SERVICE_VERSION } from \"./getAttributes.js\";\n\ntype MetricsPresets = NonNullable<\n\tIntegrationSchema[\"presets\"]\n>[\"metricExporter\"];\n\n/**\n * Check if metrics should be created based on exporter type\n */\nexport function shouldCreateMetrics(exporter: MetricsPresets): boolean {\n\tswitch (exporter) {\n\t\tcase \"prometheus\":\n\t\tcase \"http\":\n\t\tcase \"grpc\":\n\t\tcase \"proto\":\n\t\t\treturn true;\n\t\tcase \"none\":\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\n/**\n * Get the appropriate meter for metrics creation\n */\nexport function getMetricsMeter() {\n\treturn metrics.getMeter(\n\t\t\"astro-opentelemetry-integration-metrics\",\n\t\tOTEL_SERVICE_VERSION,\n\t);\n}\n\n/**\n * Create metrics based on exporter type following OpenTelemetry best practices\n */\nexport function createMetricsForExporter(exporter: MetricsPresets) {\n\tif (!shouldCreateMetrics(exporter)) {\n\t\treturn {\n\t\t\thttpRequestsTotal: null,\n\t\t\thttpRequestDuration: null,\n\t\t\thttpServerDurationSeconds: null,\n\t\t};\n\t}\n\n\tconst meter = getMetricsMeter();\n\n\tswitch (exporter) {\n\t\tcase \"prometheus\":\n\t\t\t// Create detailed metrics for Prometheus (debugging-friendly)\n\t\t\treturn {\n\t\t\t\thttpRequestsTotal: meter.createCounter(\"http_requests_total\", {\n\t\t\t\t\tdescription: \"Total number of HTTP requests\",\n\t\t\t\t}),\n\t\t\t\thttpRequestDuration: meter.createHistogram(\n\t\t\t\t\t\"http_request_duration_seconds\",\n\t\t\t\t\t{\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\"Duration in seconds of initial server-side request processing, including middleware and Astro frontmatter, measured until the response is ready to send/stream.\",\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t\thttpServerDurationSeconds: meter.createHistogram(\n\t\t\t\t\t\"http_server_duration_seconds\",\n\t\t\t\t\t{\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\"Full server-side HTTP request duration in seconds, including processing, Astro rendering, and response streaming.\",\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t};\n\n\t\tcase \"http\":\n\t\tcase \"grpc\":\n\t\tcase \"proto\":\n\t\t\t// Create essential metrics only for OTLP exporters (production-optimized)\n\t\t\treturn {\n\t\t\t\thttpRequestsTotal: null, // Skip counter for OTLP (can be derived from histogram)\n\t\t\t\thttpRequestDuration: meter.createHistogram(\n\t\t\t\t\t\"http_request_duration_seconds\",\n\t\t\t\t\t{\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\"Duration in seconds of initial server-side request processing, including middleware and Astro frontmatter, measured until the response is ready to send/stream.\",\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t\thttpServerDurationSeconds: meter.createHistogram(\n\t\t\t\t\t\"http_server_duration_seconds\",\n\t\t\t\t\t{\n\t\t\t\t\t\tdescription:\n\t\t\t\t\t\t\t\"Full server-side HTTP request duration in seconds, including processing, Astro rendering, and response streaming.\",\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t};\n\n\t\tdefault:\n\t\t\treturn {\n\t\t\t\thttpRequestsTotal: null,\n\t\t\t\thttpRequestDuration: null,\n\t\t\t\thttpServerDurationSeconds: null,\n\t\t\t};\n\t}\n}\n\n/**\n * Get the current exporter type from global presets\n */\nexport function getCurrentExporter(): MetricsPresets {\n\treturn globalThis.__OTEL_PRESETS__?.metricExporter || \"none\";\n}\n","import type { Histogram } from \"@opentelemetry/api\";\n\nexport interface TimingLabels {\n\t[key: string]: string | number;\n\tmethod: string;\n\tpath: string;\n\tstatus: string;\n}\n\nexport interface TimingOptions {\n\tstartTime: number; // performance.now() result\n\tlabels: TimingLabels;\n\thistogram: Histogram;\n}\n\n/**\n * Legacy TTLB measurement method that wraps the response stream\n * Provides high accuracy but higher CPU usage due to stream processing\n */\nexport function measureTTLBWithStreamWrapping(\n\tresponse: Response,\n\toptions: TimingOptions,\n): Response {\n\tconst { startTime, labels, histogram } = options;\n\n\tif (response.body instanceof ReadableStream) {\n\t\tconst originalBody = response.body;\n\t\tconst wrappedBody = new ReadableStream({\n\t\t\tstart(controller) {\n\t\t\t\tconst reader = originalBody.getReader();\n\t\t\t\tfunction pump(): Promise<void> {\n\t\t\t\t\treturn reader.read().then((result) => {\n\t\t\t\t\t\tif (result.done) {\n\t\t\t\t\t\t\tconst duration = (performance.now() - startTime) / 1000; // Convert to seconds\n\t\t\t\t\t\t\thistogram.record(duration, labels);\n\t\t\t\t\t\t\tcontroller.close();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontroller.enqueue(result.value);\n\t\t\t\t\t\treturn pump();\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn pump();\n\t\t\t},\n\t\t});\n\t\treturn new Response(wrappedBody, {\n\t\t\tstatus: response.status,\n\t\t\tstatusText: response.statusText,\n\t\t\theaders: response.headers,\n\t\t});\n\t}\n\n\treturn response;\n}\n\n/**\n * Optimized TTLB measurement method using async timing with response cloning\n * Provides millisecond accuracy with minimal CPU overhead\n */\nexport function measureTTLBWithAsyncTiming(\n\tresponse: Response,\n\toptions: TimingOptions,\n): Response {\n\tconst { startTime, labels, histogram } = options;\n\n\tif (response.body instanceof ReadableStream) {\n\t\t// Clone the response to avoid modifying the original\n\t\tconst clonedResponse = response.clone();\n\n\t\t// Track completion asynchronously without blocking\n\t\t// Use setImmediate to defer timing work and reduce CPU pressure\n\t\tsetImmediate(async () => {\n\t\t\ttry {\n\t\t\t\tconst reader = clonedResponse.body?.getReader();\n\t\t\t\tif (!reader) return;\n\n\t\t\t\twhile (true) {\n\t\t\t\t\tconst { done } = await reader.read();\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\tconst duration = (performance.now() - startTime) / 1000; // Convert to seconds\n\t\t\t\t\t\t// Round to millisecond precision for efficiency\n\t\t\t\t\t\tconst roundedDuration = Math.round(duration * 1000) / 1000;\n\t\t\t\t\t\thistogram.record(roundedDuration, labels);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch {\n\t\t\t\t// Silent fail for timing - don't break the response\n\t\t\t\t// Optionally log at debug level if needed\n\t\t\t}\n\t\t});\n\n\t\t// Return original response immediately\n\t\treturn response;\n\t}\n\n\treturn response;\n}\n"],"mappings":"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","names":[]}